---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "Figures/",
  out.width = "100%"
)
```
# Generating Fractal Melodies

<!-- badges: start -->
<!-- badges: end -->

A method implemented in R to generate fractal melodies using the method described by Beauvois (2007) (https://www.jstor.org/stable/10.1525/mp.2007.24.3.247). The R script generates a fractal time series, and then the Matlab script generates a MIDI sequence using that time series. The result is a melody with self-similar pitch fluctuations. Note: the Matlab script requires the MIDI Toolbox.

## Generating 1/f Time Series

The R library "fractal" is used to generate a time series that exhibits a user-specified 1/f structure, as estimated by the Hurst exponent. The time series is generated by a Fractional Guassian Noise (FGN) process, which reflects a stochastic stationary Gaussian process. Parameters for the FGN, such as the mean, variance, and Hurst exponent, can be set by the user. To estimate the 1/f structure of the generated time series, the script uses pengFit and rsFit, which are two modern methods of estimating the Hurst Exponent. Both should be used.

```{r fractal_parameters}
var = 100   # variance of distribution
mu = 100    # mean of distribution
h = 0.25    # hurst exponent
n = 2000    # sample size of time series

```


```{r fractal_ts, include = FALSE}
### Fractal Melodies ###

# Fractal package to simulate fractal time series 
library(fractal)

mod1 = lmModel("fgn", HG = h, variance = var) 
y<-lmSimulate(mod1,n.sample=n, mean = mu) 
minval = min(y)

```

A plot of the 1/f time series generated by a FGN. Note the stationarity of the time series.
```{r ts_plot, echo = FALSE}
# Plot of fractal time series
plot(y, main="Fractal Time Series")

```

```{r scaled_ts, include = FALSE}
###Step 2: Normalize Time Series, then Convert to MIDI values

#Normalized to mean = 0, sd = 1
y.scaled = scale(y, center = TRUE, scale = TRUE)

#Exponential scaling used to convert scaled time series to MIDI note values
#Method described by Beauvois, 2007
midipitch <- function(x, p) {
  #Converts a standardized time series (mean 0, sd 1)
  #to a time series of MIDI note values
  #x = time series
  #p = midi note value to standardize around; 60 = middle C
  #the time series values are truncated just to their integer part
  
  temp_x = 0
  
  for (i in 1:length(x)) {
    
    if (x[i] >= 0) { 
    temp_x[i] = trunc(p * 2^(x[i]/4))} 
    
    else {
  temp_x[i] = trunc(p - (p * 2^-(x[i]/4) - p))} 
  }

  return(temp_x)
}

### Step 3: Exponential scaling around MIDI note value 60 (middle C) ###
y.MP = midipitch(y.scaled, 60)

  
```


Next, the time series is standardized (i.e., mean = 0, SD = 1) before it is converted to MIDI note values using a method described by Beauvois (2007). The result is a vector of MIDI note values that exhibit 1/f pitch fluctuations that can be used to generate fractal melodies. Here, the pitch fluctuations are centered around a note value of 60 (i.e., center C).

```{r notevalue_ts, echo = FALSE}

# Plot of scaled fractal time series
plot(y.MP, main="Fractal Melody: MIDI Note Values", pch = 3, ylab = "MIDI Note Value", xlab = "Note Number")


```
